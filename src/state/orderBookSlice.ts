import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit"
import axios from "axios"
import { RootState, AppThunk } from "./store"
import { update } from "./accountSlice"
import { ORDERBOOK_LEVELS, API_URL } from "../constants"

export interface Order {
  quantity: number
  price: number
  totalSum: number
  depth: number
}

export interface OrderBookState {
  bids: any
  asks: any
  status: "idle" | "loading" | "failed"
}

const initialState: OrderBookState = {
  bids: [],
  asks: [],
  status: "idle",
}

// dispatch(getOrderBook())
export const getOrderBook = createAsyncThunk(
  "orderbook/getOrderBook",
  async () => {
    const opts = {
      withCredentials: true,
    }
    const response = await axios.get(`${API_URL}/orderbook/`, opts)
    // The value ` action payload
    return response.data
  },
)

export const orderBookSlice = createSlice({
  name: "orderbook",
  initialState,
  reducers: {
    clear: (state) => {
      state.bids = []
      state.asks = []
    },
  },

  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(getOrderBook.pending, (state) => {
        state.status = "loading"
      })
      .addCase(getOrderBook.fulfilled, (state, action) => {
        state.status = "idle"
        console.log(action.payload)
        let bids = action.payload.bids
        bids = bids.reverse()
        bids = bids.slice(0, ORDERBOOK_LEVELS)
        bids = addTotalSums(bids)
        bids = addDepths(bids)

        let asks = action.payload.asks
        asks = asks.slice(0, ORDERBOOK_LEVELS)
        asks = addTotalSums(asks)
        asks = addDepths(asks)

        state.bids = bids
        state.asks = asks

        // const sumBids = addTotalSums(state.bids)
        // console.log(sumBids)
        update(action)
      })
      .addCase(getOrderBook.rejected, (state) => {
        state.status = "failed"
      })
  },
})

const ordersToArray = (orders: any): any => {
  const orderArray: any = []
  for (const [key, value] of Object.entries(orders)) {
    orderArray.push([Number(key), Number(value)])
  }
  return orderArray
}

const addTotalSums = (orders: Order[]): Order[] => {
  const totalSums: number[] = []

  return orders.map((order, idx) => {
    const { quantity } = order
    if (typeof order.totalSum !== "undefined") {
      return order
    } else {
      const updatedLevel = { ...order }
      const totalSum: number = idx === 0 ? quantity : quantity + totalSums[idx - 1]
      updatedLevel.totalSum = totalSum
      totalSums.push(totalSum)
      return updatedLevel
    }
  })
}

const addDepths = (orders: Order[]) => {
  const totalSums: number[] = orders.map((order) => order.totalSum)
  const maxTotal = Math.max.apply(Math, totalSums)
  return orders.map((order) => {
    if (typeof order.depth !== "undefined") {
      return order
    } else {
      const calculatedTotal: number = order.totalSum
      const depth = (calculatedTotal / maxTotal) * 100
      const updatedOrder = { ...order }
      updatedOrder.depth = depth
      return updatedOrder
    }
  })
}

export const { clear } = orderBookSlice.actions
export const orderBook = (state: RootState) => state.orderBook
export default orderBookSlice.reducer
