import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import axios from "axios";
import { RootState } from "./store";
import { update } from "./accountSlice";
import { ORDERBOOK_LEVELS, API_URL } from "../constants";

interface Order<T> {
  quantity: T;
  price: T;
}

interface OrderWithTotal extends Order<number> {
  totalSum: number;
}
export interface OrderWithDepth extends OrderWithTotal {
  depth: number;
}

export interface OrderBookState {
  bids: OrderWithDepth[];
  asks: OrderWithDepth[];
  status: "idle" | "loading" | "failed";
}

const initialState: OrderBookState = {
  bids: [],
  asks: [],
  status: "idle",
};

// dispatch(getOrderBook())
export const getOrderBook = createAsyncThunk(
  "orderbook/getOrderBook",
  async () => {
    const opts = {
      withCredentials: true,
    };
    const response = await axios.get(`${API_URL}/orderbook?ticker=BTCUSDT.P`);
    // The value ` action payload
    return response.data;
  }
);

export const orderBookSlice = createSlice({
  name: "orderbook",
  initialState,
  reducers: {
    clear: (state) => {
      state.bids = [];
      state.asks = [];
    },
  },

  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(getOrderBook.pending, (state) => {
        state.status = "loading";
      })
      .addCase(getOrderBook.fulfilled, (state, action) => {
        state.status = "idle";
        let bids = action.payload.bids;
        bids = bids.slice(0, ORDERBOOK_LEVELS);
        bids = formatToNumbers(bids);
        bids = addTotalSums(bids);
        bids = addDepths(bids);

        let asks = action.payload.asks;
        asks = asks.slice(0, ORDERBOOK_LEVELS);
        asks = asks.reverse();
        asks = formatToNumbers(asks);
        asks = addTotalSums(asks);
        asks = addDepths(asks);

        state.bids = bids;
        state.asks = asks;
        update(action);
      })
      .addCase(getOrderBook.rejected, (state) => {
        state.status = "failed";
      });
  },
});

const addTotalSums = (orders: Order<number>[]): OrderWithTotal[] => {
  const totalSums: number[] = [];

  return orders.map((order, idx) => {
    const { quantity } = order;
    const updatedLevel: OrderWithTotal = { ...order, totalSum: 0 };
    const totalSum: number =
      idx === 0 ? quantity : quantity + totalSums[idx - 1];
    updatedLevel.totalSum = totalSum;
    totalSums.push(totalSum);
    return updatedLevel;
  });
};

const addDepths = (orders: OrderWithTotal[]): OrderWithDepth[] => {
  const totalSums: number[] = orders.map((order) => order.totalSum);
  const maxTotal = Math.max.apply(Math, totalSums);
  return orders.map((order) => {
    const calculatedTotal: number = order.totalSum;
    const depth = (calculatedTotal / maxTotal) * 100;
    const updatedOrder: OrderWithDepth = { ...order, depth: 0 };
    updatedOrder.depth = depth;
    return updatedOrder;
  });
};

const formatToNumbers = (orders: Order<string>[]): Order<number>[] =>
  orders.map((bind) => ({
    quantity: +bind.quantity,
    price: +bind.price,
  }));

export const { clear } = orderBookSlice.actions;
export const orderBook = (state: RootState) => state.orderBook;
export default orderBookSlice.reducer;
