import { createSlice } from "@reduxjs/toolkit";
import { RootState } from "./store";
import { ORDERBOOK_LEVELS } from "../constants";
import { orderBookApi } from "../utils/api/orderBookApi";
import { Order, OrderWithDepth, OrderWithTotal } from "../types/orderBook";
import { pipe } from "../utils/pipe";

export interface OrderBookState {
  bids: OrderWithDepth[];
  asks: OrderWithDepth[];
  status: "idle" | "loading" | "failed";
}

const initialState: OrderBookState = {
  bids: [],
  asks: [],
  status: "idle",
};

export const orderBookSlice = createSlice({
  name: "orderbook",
  initialState,
  reducers: {
    clear: state => {
      state.bids = [];
      state.asks = [];
    },
  },

  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: builder => {
    builder
      .addMatcher(orderBookApi.endpoints.getOrderBook.matchPending, state => {
        state.status = "loading";
      })
      .addMatcher(
        orderBookApi.endpoints.getOrderBook.matchFulfilled,
        (state, { payload }) => {
          state.status = "idle";
          const bids = payload.bids
            ? pipe(
                payload.bids.slice(0, ORDERBOOK_LEVELS),
                formatToNumbers,
                addTotalSums,
                addDepths
              )
            : [];
          const asks = payload.asks
            ? pipe(
                payload.asks.slice(0, ORDERBOOK_LEVELS),
                formatToNumbers,
                addTotalSums,
                addDepths
              )
            : [];

          state.bids = bids;
          state.asks = asks;
        }
      )
      .addMatcher(orderBookApi.endpoints.getOrderBook.matchRejected, state => {
        state.status = "failed";
      });
  },
});

const addTotalSums = (orders: Order<number>[]): OrderWithTotal[] => {
  const totalSums: number[] = [];

  return orders.map((order, idx) => {
    const { quantity } = order;
    const updatedLevel: OrderWithTotal = { ...order, totalSum: 0 };
    const totalSum: number =
      idx === 0 ? quantity : quantity + totalSums[idx - 1];
    updatedLevel.totalSum = totalSum;
    totalSums.push(totalSum);
    return updatedLevel;
  });
};

const addDepths = (orders: OrderWithTotal[]): OrderWithDepth[] => {
  const totalSums: number[] = orders.map(order => order.totalSum);
  const maxTotal = Math.max.apply(Math, totalSums);
  return orders.map(order => {
    const calculatedTotal: number = order.totalSum;
    const depth = (calculatedTotal / maxTotal) * 100;
    const updatedOrder: OrderWithDepth = { ...order, depth: 0 };
    updatedOrder.depth = depth;
    return updatedOrder;
  });
};

const formatToNumbers = (orders: Order<string>[]): Order<number>[] =>
  orders.map(bind => ({
    quantity: +bind.quantity,
    price: +bind.price,
    leverage: bind.leverage,
  }));

export const { clear } = orderBookSlice.actions;
export const orderBook = (state: RootState) => state.orderBook;
export default orderBookSlice.reducer;
